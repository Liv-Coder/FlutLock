# FlutLock Project Intelligence

## Project Patterns

- Python-based command-line tool for automating Flutter app signing
- Focus on security and ease of use for the signing process
- Cross-platform compatibility is essential (Windows, macOS, Linux)
- Starting with a simple approach and evolving to more complex features
- Using custom exception classes to categorize different types of errors

## Naming Conventions

- Use clear, descriptive function and variable names
- Follow Python PEP 8 style guidelines
- Use snake_case for variables and functions
- Use CamelCase for classes
- Error classes should have descriptive names ending with "Error"

## Security Considerations

- Never hardcode credentials or sensitive information
- Use environment variables or secure input methods for passwords
- Validate all user inputs
- Handle keystores with appropriate file permissions
- Check password strength and provide warnings for weak passwords

## Development Workflow

- Start with a minimal, functional approach
- Use modular functions that can be tested independently
- Document code thoroughly
- Consider cross-platform compatibility in all operations
- Implement comprehensive error handling with specific guidance

## Error Handling Patterns

- Use custom exception classes inheriting from a base FlutLockError
- Provide detailed error messages with troubleshooting steps
- Include fallback mechanisms where appropriate
- Structure error handling with try/except blocks for clarity
- Validate input early to catch errors before processing
- Set appropriate file permissions and handle permission errors
- Check for missing dependencies with clear installation guidance

## Git Workflow

- Two main branches: `main` (stable) and `development` (ongoing work)
- Feature branches should be created from `development`
- Pull requests should target `development` branch
- Only merge to `main` when code is fully tested and ready for release
- CI workflow runs tests on all branches
- Deployment steps only run on `main` branch
- Tag releases using semantic versioning (e.g., v1.0.0)

## User Preferences

- Clear, informative command-line output
- Guided experience with helpful error messages
- Option for non-interactive mode in CI/CD environments
- Security and reliability are top priorities
- Providing detailed troubleshooting steps for common errors

## Code Organization Patterns

- Follow Python package-based architecture
- Place imports in logical order (standard library, then third-party, then local)
- Consolidate similar functionality into single modules
- Integrate feature-related code into core modules rather than creating separate ones
- Ensure backward compatibility for existing users
- Maintain clear entry points with consistent interfaces
- Document the purpose of each module at the top of the file
- Keep entry point scripts minimal, delegating to the package for actual functionality
- Prefer class-based exceptions for better error categorization
- Use command-line argument groups for better organization
- Implement verbose/quiet modes consistently across all modules
